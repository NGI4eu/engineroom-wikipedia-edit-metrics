# -*- coding: utf-8 -*-import MySQLdb as mdbimport sysimport codecsimport datetimeimport urllibimport rereload(sys)sys.setdefaultencoding('utf-8')if sys.stdout.encoding is None:	sys.stdout = codecs.open("/dev/stdout", "w", 'utf-8')### SETTINGS# set username and password for the Wikimedia Tool labs databasewith open('DB_info') as DB_info:	DB_USER_NAME = DB_info.readline().strip('\n')	DB_PASSWORD = DB_info.readline().strip('\n')	#directory to store input and output files	data_dir = sys.argv[1]#~ page_title = sys.argv[2]#~ article_id = int(sys.argv[2])name = sys.argv[2]page_list_file = sys.argv[3]ARRAY_SIZE = 10000 verbose = Truevery_verbose = Truefrom_file = Truelimit_pages = 0 #10000END_DATE='20180801000000'#END_DATE='20111208000000'#~ END_DATE='20140403000000'if verbose: print 'limit: %d, end_date:%s' % (limit_pages, END_DATE)reverted_nc_p = re.compile(r'^(?:JS: )?(?:Reverted|Revert|\[\[Help:Reverting\|Reverted\]\]|\[\[WP:RBK\|Reverted\]\])(?: (?:\d+ )?(?:pendent )?edit(?:s)? (?:by|of) (?:(?:\[\[User:[^]]+\]\]|\d+\.\d+\.\d+\.\d+|[^][.;\s]+(?: [^][.;\s]+)?(?: [^][.;\s]+)?|\[\[[S|s]pecial:[C|c]ontrib(?:ution)?s/[^]]+\]\])(?: \(?\[\[User[ _]talk:[^]]+\]\]\)?)?))?(?: identified as (?:(?:test/)?vandalism|\[\[WP:VAND\|vandalism\]\]))?(?:(?:, changed back)?\s+to(?: the)?(?:(?: last| previous)?(?: revision| version| edit)(?: \(\d+\))?|(?: revision| version) \d+)(?: made)? (?:by|from)\s+(?:(?:\[\[User:[^]]+\]\]|\d+\.\d+\.\d+\.\d+|[^][.;\s]+(?: [^][.;\s]+)?(?: [^][.;\s]+)?|\[\[[S|s]pecial:[C|c]ontrib(?:ution)?s/[^]]+\]\])(?: \(\[\[User[ _]talk:[^]]+\]\]\))?))?\.?(?:\.? ?[Uu]sing \[\[[^]]+\]\])?(?:\.? ?\((?:[Uu]sing )?\[\[(?:WP:(?:HG|TW|TWINKLE|VPRF|)|User:Ale_jrb/Scripts/igloo)\|[^]]+\]\]\)| \[\[(?:WP:(?:HG|TW|TWINKLE|VPRF|)|User:Ale_jrb/Scripts/igloo)\|[^]]+\]\])?(?: \(\d+\.\d+(?:\.\d+)?\))?\.?\s*$')revert_nc_p = re.compile(r'^Revert(?: to(?: the revision prior to)? revision(?: \d+)?(?: dated (?:\S+ \S+|\S+, \S+ \S+ \S+))?(?: by \S+?\s*?\S*?\s*?\S*?)?(?: , oldid \d+)?(?:\.? ?[Uu]sing \[\[\S+?\]\](?: \S*\s*\S*)?)?)?\.?\s*$')undid_nc_p = re.compile(r'^(?:\[\[WP:AES|[^]]+\]\])?(?:Undid|\[\[WP:(?:UNDO|\S)\|Undid\]\]) revision (?:\d+) by \[\[[^]]+\]\] \(\[\[User talk:[^\|]+\|talk\]\]\)(?: to last version by \[\[[S|s]pecial:[C|c]ontrib(?:ution)?s/[^\|]+\|[^]]+\]\])?$')title_nc_p = re.compile(r'^/\* .+ \*/$')users = {}ipP = re.compile(r'\d+\.\d+\.\d+\.\d+')def isIP(s):	if ipP.match(s): return True	else: return Falsestore_all_users = Truestore_revisions = Truestore_pairs = Falsestore_net = Falsestore_ec = Falsestore_user_edits = Falsestore_reverts = Truestore_reverts_simple = Truestore_pages = Truestore_page_user_edits = Falsenon_nc_tot = 0nc_tot = 0if store_revisions:	f_revisions = codecs.open(data_dir + name + '_revisions.csv', 'w', 'utf-8')		if store_pairs:	f_pairs = codecs.open(data_dir + name + '_pairs.csv', 'w', 'utf-8')		if store_net:	f_net = codecs.open(data_dir + name + '_revert_net.csv', 'w', 'utf-8')	if store_ec:	f_ec = codecs.open(data_dir + name + '_edit_count.csv', 'w', 'utf-8')	if store_user_edits:	f_user_edits = codecs.open(data_dir + name + '_user_edits.csv', 'w', 'utf-8')	f_user_edits.write('rev_id\tpage_id\tuser_id\tuser_name\tts\trev_len\tminor_edit\tedit_len\treverted_rev_id\treverted_user\treverted_user_id\treverted_reg\trevert_back\tself_restored\tuser_ec\treverted_user_ec\trevert_nc\n')	if store_page_user_edits:	f_page_user_edits = codecs.open(data_dir + name + '_page_user_edits.csv', 'w', 'utf-8')	f_page_user_edits.write('\t'.join(['page_id','user_id','username','edits','neg_edits','bytes_added','bytes_deleted','reverts','self_restores','reverts_reg','reverts_nc','reverts_nc_reg','reverts_back','reverts_back_reg']) + '\n')if store_reverts:	f_reverts = codecs.open(data_dir + name + '_reverts.csv', 'w', 'utf-8')if store_reverts_simple:	f_reverts_simple = codecs.open(data_dir + name + '_reverts_simple.csv', 'w', 'utf-8')	f_reverts_simple.write('page_id\trev_num\trev_id\tuser_id\tusername\ttimestamp\trev_len\trev_num_1\trev_id_1\tuser_id_1\tusername_1\ttimestamp_1\trev_len_1\t' + '\t'.join(['len_diff', 'no_comment', 'reverted_reg', 'self_restored', 'self_restored_indirect', 'revert_back', 'revert_back_check', 'revert_back_back', 'revert_back_back_check', 'revert_chain_length', 'revert_consec_chain_length', 'user_ec', 'reverted_user_ec']) + '\n')	if store_pages:	f_pages = codecs.open(data_dir + name + '_pages.csv', 'w', 'utf-8')		f_pages.write('page_id\ttitle\ttot_edits\ttot_users\tn_reverts\trevert_users\tmutual_reverts\tmutual_reverting_users\tM\tM_final\ttot_edits_reg\ttot_users_reg\tn_reverts_reg\trevert_users_reg\tmutual_reverts_reg\tmutual_reverting_users_reg\tM_reg\tM_final_reg\tsample_users\n')					def load_dic(filename):	d = {}	with codecs.open(filename, 'r', 'UTF-8') as f:		f.readline()		for line in f:			s = line.strip('\n').split('\t')			if len(s) > 1 and s[0][0] != '#':				d[int(s[0])] = line.strip('\n')		if verbose: print 'loaded %d items from file %s' %(len(d), filename)				return d		def load_keys(filename):	d = {}	with codecs.open(filename, 'r', 'UTF-8') as f:		f.readline()		for line in f:			s = line.strip('\n').split('\t')			if len(s) > 1 and s[0][0] != '#':				d[int(s[0])] = 1 # [s[1]]		if verbose: print 'loaded %d items from file %s' %(len(d), filename)				return d				#users = load_keys('en_users.csv')										def min(a,b):	if a <= b: return a	else: return bdef empty_comment(comment):	 if comment == ' ': return True	 if (reverted_nc_p.match(comment)): return True	 if (undid_nc_p.match(comment)): return True	 if (revert_nc_p.match(comment)): return True	 if (title_nc_p.match(comment)): return True	 else: return False					def extract_page_reverts(page_id, page_title, mysql_cur):		global non_nc_tot	global nc_tot	if very_verbose: print ">>> [", datetime.datetime.now(), "] Get revisions of: ",str(page_id), page_title	mysql_cur.execute('SELECT rev_id, rev_user, rev_user_text, rev_timestamp, rev_len, rev_minor_edit, rev_comment, rev_sha1'				+ '\nFROM revision ' 				+ '\nWHERE rev_page=%d AND rev_timestamp<\'%s\' ORDER BY rev_timestamp' %(page_id, END_DATE) ) 	prev_month = ''	rows_found = 0	shas = {}	revisions = []	reverts = {}	edit_count = {}	result = [1]	j = 0	prev_rev_len = 0	edit_len = {}	user_edits = {}	n_reverts = 0		reg = False	revisions_reg = 0	n_reverts_reg = 0	users_reg = {}	revert_users_reg = 0		M = 0	top_pair = 0	top_pair_weight = 0	mutual_reverting_users = 0	mutual_revs = 0		M_reg = 0	top_pair_reg = 0	top_pair_weight_reg = 0	mutual_reverting_users_reg = 0	mutual_revs_reg = 0			errors = 0		while result:		j += 1		if very_verbose: print 'fetching results. iteration n %d' %(j)		result = mysql_cur.fetchmany(ARRAY_SIZE)		if very_verbose: print '%d rows' %len(result)		rows_found += len(result)		reverted_user = ''		revert_consec_chain_length = 0		revert_chain_length = 0					for row_tuple in result:										prev_reverted_user = ''			if reverted_user and reverted_user != '':				prev_reverted_user = reverted_user						prev_consec_chain_length = revert_consec_chain_length				revert_consec_chain_length	= 0			revert_chain_length	= 0				reverted = -1			restored = -1			revert_back = 0			revert_back_back = 0			revert_back_check = 0			revert_back_back_check = 0			reverted_reg = 0			self_restored = 0			self_restored_indirect = 0			no_comment = 0			reverted_user = ''			reverted_user_id = -1			reverted_user_ec = 0			reverted_rev_id = -1			row = list(row_tuple)			if row[6]: row[6] = row[6].replace('\n', ' <LF> ')			rev_id,user,username,ts, rev_len, minor_edit, comment, sha1 = row 			month = ts[:6]						if month != prev_month:				test = ''																n = len(revisions)			#save metadata about each revision, including two variables for the username of the reverted user (by default empty) and the length of the reply chain between the two users			revisions.append(list(row) + ['', 0])  							if username and not isIP(username): 				reg = True				revisions_reg += 1				users_reg[user] = 1			if username not in edit_count:				edit_count[username] = {'id':user, 'edits':0}			edit_count[username]['edits'] += 1	 			user_ec = edit_count[username]['edits']			edit_len = 0			if rev_len:				edit_len = rev_len - prev_rev_len																			if sha1 in shas:				restored = shas[sha1] #[-1]				if n - restored > 1: 					reverted = restored + 1					reverted_rev_id = revisions[reverted][0]					reverted_user = revisions[reverted][2]										if reverted_user == username:						reverted_user_id = -2										else:						revisions[n][-2] = reverted_user						n_reverts += 1						revert_consec_chain_length	= 1												#if the reverted revision was a revert against the current user, than this is a chain. Increment the length of the chain (between the same two users)						revert_chain_length = 1 						if revisions[reverted][-2] == username:							revert_chain_length += revisions[reverted][-1]						revisions[n][-1] = revert_chain_length												if reverted_user:							if not isIP(reverted_user):								reverted_reg = 1								if reg:									n_reverts_reg += 1														reverted_user_id = revisions[reverted][1]						reverted_user_ec = edit_count[reverted_user]['edits']								if revisions[restored][2] == username:							self_restored = 1							if n - restored > 2:								self_restored_indirect = 1														if prev_reverted_user != '' and prev_reverted_user == username:							revert_consec_chain_length = 1 + prev_consec_chain_length																						if reverted_user in reverts and username in reverts[reverted_user] and len(reverts[reverted_user][username]['info']) > 0: #user name or id?							revert_back_check = 1								if '21' in reverts[reverted_user][username]['seq']:								revert_back_back_check = 1															if username in reverts and reverted_user in reverts[username] and reverts[username][reverted_user]['back'] > 0:							revert_back = 1								if '12' in reverts[username][reverted_user]['seq']:								revert_back_back = 1						 								if not comment or len(comment) < 1 or empty_comment(comment): 							no_comment = 1							nc_tot += 1						else:							non_nc_tot += 1							if store_reverts or store_pairs or (store_reverts_simple and (store_all_users or user in users or reverted_user_id in users)):										revert_info = '\t'.join(map(str, [page_id, n, rev_id, user, username, ts, rev_len, comment, reverted] + revisions[reverted][0:7] + [self_restored, self_restored_indirect, reverted_reg, revert_back, revert_back_back, revert_chain_length, no_comment, user_ec, reverted_user_ec])) + '\n'							weight = min(user_ec, reverted_user_ec)														if username not in reverts:								reverts[username] = {}							if reverted_user not in reverts[username]:								reverts[username][reverted_user] = {'info': [], 'back': 0, 'seq':'', 'revisions':'', 'weight':0} 							reverts[username][reverted_user]['info'].append(revert_info)							reverts[username][reverted_user]['seq'] += '1'							reverts[username][reverted_user]['revisions'] += str(n)+'|'							reverts[username][reverted_user]['weight'] += weight							if reverted_user not in reverts:								reverts[reverted_user] = {}							if username not in reverts[reverted_user]:								reverts[reverted_user][username] = {'info':[], 'back': 0, 'seq':'', 'revisions':'', 'weight':0} 							reverts[reverted_user][username]['seq'] += '2'							reverts[reverted_user][username]['revisions'] += str(n)+'|'							reverts[reverted_user][username]['back'] += 1							reverts[reverted_user][username]['weight'] += weight											if store_reverts_simple and (store_all_users or user in users or reverted_user_id in users):							f_reverts_simple.write('\t'.join(map(str, [page_id, n, rev_id, user, username, ts, rev_len, reverted] + revisions[reverted][0:5] + [edit_len, no_comment, reverted_reg, self_restored, self_restored_indirect, revert_back, revert_back_check, revert_back_back, revert_back_back_check, revert_chain_length, revert_consec_chain_length, user_ec, reverted_user_ec])) + '\n')			shas[sha1] = n 			if user in users and store_user_edits:				if user not in user_edits:					user_edits[user] = {'username':username, 'edits': 0, 'neg_edits': 0, 'added': 0, 'deleted': 0, 'reverts': 0, 'self_restores': 0, 'reverts_reg': 0,'reverts_nc': 0, 'reverts_nc_reg': 0, 'reverts_back': 0, 'reverts_back_reg': 0}				user_edits[user]['edits'] += 1									if edit_len < 0:					user_edits[user]['neg_edits'] += 1					user_edits[user]['deleted'] += edit_len				else: 					user_edits[user]['added'] += edit_len										if reverted >= 0:					user_edits[user]['reverts'] += 1					if self_restored: 						user_edits[user]['self_restores'] += 1					if reverted_reg:						user_edits[user]['reverts_reg'] += 1						if no_comment:						user_edits[user]['reverts_nc'] += 1						if reverted_reg:							user_edits[user]['reverts_nc_reg'] += 1											if revert_back:							user_edits[user]['reverts_back'] += 1						if reverted_reg:							user_edits[user]['reverts_back_reg'] += 1												line = '\t'.join(map(str,[rev_id,page_id,user,username,ts,rev_len,minor_edit, edit_len, reverted_rev_id, reverted_user, reverted_user_id, reverted_reg, revert_back, self_restored, user_ec, reverted_user_ec, no_comment ])) + '\n'				try:					f_user_edits.write(line)				except:					try:						line_decoded = line.decode("ISO-8859-1")						f_user_edits.write(line_decoded)						if very_verbose: print '\n\n\n\n\nsuccessfully decoded!! \n\n' + line_decoded + '\n\n\n\n\n' 					except:						line_stripped = unicode(line, errors='ignore')						f_user_edits.write(line_stripped)						if very_verbose: print '\n\n\n\n\nsuccessfully stripped!! \n\n' + line_stripped + '\n\n\n\n\n'										if rev_len:					prev_rev_len = rev_len					if store_revisions:		for i in range(len(revisions)):			#### TO AVOID ENCODING ERROR... TO BE ADDRESSED IN A CLEANER WAY! :) 			try:				f_revisions.write(str(i) + '\t' + '\t'.join(map(str,revisions[i])) + '\n')			except:				print 'skipping bad line for encoding issues', i					if store_pairs or store_reverts or store_pages: # or store_reverts_simple:		for u1 in reverts:			if u1 and not isIP(u1): revert_users_reg += 1			mutual_rev_users = 0			mutual_rev_users_reg = 0			for u2 in reverts[u1]:				if u1 and u2:					both_reg = False					if not (isIP(u1) or isIP(u2)): both_reg = True						ec1 = 0					ec2 = 0					id1 = -1					id2 = -1					if u1 in edit_count: 						ec1 = edit_count[u1]['edits']						id1 = edit_count[u1]['id']					if u2 in edit_count: 						ec2 = edit_count[u2]['edits']						id2 = edit_count[u2]['id']																	if store_pairs and (store_all_users or user in users or reverted_user_id in users):						f_pairs.write('\t'.join(map(str,[page_id, u1,u2,id1,id2, ec1, ec2, len(reverts[u1][u2]['info']), reverts[u1][u2]['back'], reverts[u1][u2]['seq'],reverts[u1][u2]['revisions'] ])) + '\n')  #  +revisions[reverts[u1][u2]]+revisions[el[1][0]]+revisions[el[0][2]]+revisions[el[1][2]])) + '\n')					mutual_rev = False					if len(reverts[u1][u2]['info']) > 0 and reverts[u1][u2]['back'] > 0:						mutual_rev = True						mutual_rev_users += 1						mutual_revs += 1						if both_reg:							mutual_rev_users_reg += 1							mutual_revs_reg += 1					if store_pages and u1 < u2:						if mutual_rev:							mutual = len(reverts[u1][u2]['info']) + reverts[u1][u2]['back']							pair_weight = reverts[u1][u2]['weight']							if mutual > top_pair:								top_pair_weight = pair_weight							M += pair_weight														if both_reg:								if mutual > top_pair_reg:									top_pair_weight_reg = pair_weight								M_reg += pair_weight														if store_reverts:						for r in reverts[u1][u2]['info']:							if store_all_users or user in users or reverted_user_id in users:								try:									f_reverts.write(r +  '\t'.join(map(str,[ec1, ec2])) + '\n')  # '\t' + str(ec1)  + '\t' + str(ec2)  + '\n')   								except:									try:										r_decoded = r.decode("ISO-8859-1")										f_reverts.write(r_decoded +  '\t'.join(map(str,[ec1, ec2])) + '\n') 										if very_verbose: print '\n\n\n\n\nsuccessfully decoded!! \n\n' + r_decoded + '\n\n\n\n\n' 									except:										try:											r_stripped = unicode(r, errors='ignore')											f_reverts.write(r_stripped +  '\t'.join(map(str,[ec1, ec2])) + '\n') 											if very_verbose: print '\n\n\n\n\nsuccessfully stripped!! \n\n' + r_stripped + '\n\n\n\n\n' 										except:											errors += 0										if mutual_rev_users > 0:				mutual_reverting_users += 1			if mutual_rev_users_reg > 0:				mutual_reverting_users_reg += 1															if store_net:		for u1 in reverts:			for u2 in reverts[u1]:				for r in reverts[u1][u2]['info']:					f_net.write(u1.replace(' ','_') + '\t' + u2.replace(' ','_') + '\n') 									if store_ec:		for u in edit_count:			f_ec.write(str(page_id) + '\t' + str(edit_count[u]['id']) + '\t' + str(u) + '\t' + str(edit_count[u]['edits']) + '\n')			if store_page_user_edits:		for u in user_edits:				f_page_user_edits.write('\t'.join(map(str, [page_id, u] + [user_edits[u]['username'], user_edits[u]['edits'], user_edits[u]['neg_edits'], user_edits[u]['added'], user_edits[u]['deleted'], user_edits[u]['reverts'], user_edits[u]['self_restores'], user_edits[u]['reverts_reg'], user_edits[u]['reverts_nc'], user_edits[u]['reverts_nc_reg'], user_edits[u]['reverts_back'], user_edits[u]['reverts_back_reg'] ] ))  + '\n')		if store_pages: # and len(revisions) > 1:		M_final = (M-top_pair_weight) * mutual_reverting_users		M_final_reg = (M_reg - top_pair_weight_reg) * mutual_reverting_users_reg		f_pages.write('\t'.join(map(str, [page_id, page_title, len(revisions), len(edit_count), n_reverts,  len(reverts), mutual_revs, mutual_reverting_users, M, M_final, revisions_reg, len(users_reg), n_reverts_reg, revert_users_reg, mutual_revs_reg, mutual_reverting_users_reg, M_reg, M_final_reg, len(user_edits)])) + '\n') 					return len(revisions), len(edit_count), n_reverts, len(reverts)	### EXECUTEprint "Current date and time [START]: " , datetime.datetime.now()mysql_con = mdb.connect('enwiki.labsdb', DB_USER_NAME, DB_PASSWORD, 'enwiki_p')with mysql_con:	mysql_cur = mysql_con.cursor()	i = 0	if from_file:		#~ with open('All_Articles_by_id.csv') as f:		with open(page_list_file) as f:			for line in f:				i += 1				c = line.strip('\n').split('\t')				if len(c)<2 or c[1] == '':					print 'skipping line: ', line				else:						p_id = int(c[1])					p_title = c[0]					extract_page_reverts(p_id, p_title, mysql_cur)					if i%100000 == 0: 						print '%d pages processed' % i						if store_page_user_edits: f_page_user_edits.flush()						if store_user_edits: f_user_edits.flush()				if i==limit_pages: break 	else:		mysql_cur.execute('SELECT page_id, page_title FROM page WHERE page_namespace=0 ORDER BY page_id')		res = [1]		j = 0		i = 0		rows_found = 0		while res:			j += 1			print '%d pages processed. Fetching page results, iteration n %d' %(i, j)			res = mysql_cur.fetchmany(ARRAY_SIZE)			print '%d rows found' %(len(res))			rows_found += len(res)						for row_tuple in res:				i += 1				p_id, p_title = row_tuple				extract_page_reverts(p_id, p_title, mysql_cur)	if verbose: print 'End - %d pages processed' %i #rows_found		print 'reverts_nc: %d, %.2f' % (nc_tot, nc_tot*100.0/(non_nc_tot + nc_tot)) print "Current date and time [FIN]: " , datetime.datetime.now()